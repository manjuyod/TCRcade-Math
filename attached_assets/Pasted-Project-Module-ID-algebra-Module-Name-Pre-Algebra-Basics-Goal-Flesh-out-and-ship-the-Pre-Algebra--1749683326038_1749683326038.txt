Project
Module ID: algebra
Module Name: Pre‑Algebra Basics
Goal: Flesh out and ship the Pre‑Algebra Basics module so it works end‑to‑end in the web app.

High‑Level Requirements
Start‑Up Flow

Entry point: client/src/pages/algebra/setup-page.tsx.

Three buttons are rendered: Test (disabled for now), Practice Run, Token Run.

Practice Run Path

On click, navigate to a loading page.

Run

sql
Copy
SELECT
  (hidden_grade_asset #>> '{modules,algebra,grade_level}')::int    AS grade_level,
  (hidden_grade_asset #>> '{modules,algebra,progress,lesson}')::int AS lesson
FROM users
WHERE id = <CURRENT_USER_ID>;
With grade_level & lesson, query

sql
Copy
SELECT * FROM questions_algebra
WHERE GradeLevel = :grade_level
  AND Lesson     = :lesson
  AND Section ILIKE '%tryit%';
Pre‑load exactly five random “TryIt” questions. If fewer than five are returned, keep sampling until five are reached.

Question types: MC (multiple choice) and FR (free response) – handle both.

Navigate to client/src/pages/algebra/play-page.tsx.

Parsing rules

Questions: If the string contains ^<number>, render the <number> as a superscript (drop the ^).

Answers: If a string starts with [ and ends with ], treat it as a JSON‑style list of acceptable answers. Remove the brackets before display.

No tokens awarded; no penalties.

On completion, show stats in client/src/pages/algebra/complete-page.tsx then route home.

Token Run Path

Same initial user query as Practice Run.

Run two SQL queries:

Non‑TryIt, non‑challenge:

sql
Copy
SELECT * FROM questions_algebra
WHERE GradeLevel = :grade_level
  AND Lesson     = :lesson
  AND Section NOT ILIKE '%tryit%'
  AND Section NOT ILIKE '%challenge%';
Challenge only:

sql
Copy
SELECT * FROM questions_algebra
WHERE GradeLevel = :grade_level
  AND Lesson     = :lesson
  AND Section ILIKE '%challenge%';
Pre‑load 4 random non‑TryIt questions (add extras as needed to reach four) then 1 random challenge question.

Same parsing rules as Practice Run.

Scoring & token logic (client‑side first, then persist to DB for accuracy):

≥ 80 % correct → 5 tokens; 100 % → 8 tokens.

DB updates:

Success (≥ 80 %):

sql
Copy
UPDATE users
SET hidden_grade_asset = jsonb_set(hidden_grade_asset,
          '{modules,algebra,progress,attempt_bad}', '0', false)
    || jsonb_set(hidden_grade_asset,
          '{modules,algebra,progress,attempt_good}',
          COALESCE((hidden_grade_asset #>> '{modules,algebra,progress,attempt_good}')::int,0) + 1, false)
WHERE id = <CURRENT_USER_ID>;
Failure (< 80 %): analogous but swap attempt_good ↔ attempt_bad.

On attempt_good = 3, level‑up (if higher grade exists in questions_algebra); on attempt_bad = 3, level‑down (if lower grade exists). Reset both counters to 0 and show a level‑change page before the standard complete page.

Complete page: client/src/pages/algebra/complete-page.tsx.

Client Code Touch‑Points

modules-page.tsx already routes modules; adjust logic if needed.

All shared rules/config live under shared/.

Server Code

Create measurements.ts equivalent for algebra: algebra.ts (or rename per convention) in server folder with relevant service functions.

Update routes.ts to wire new endpoints.

Acceptance Checklist
 All pages compile and route without TypeScript errors.

 SQL queries are parameterized (no interpolation).

 Five TryIt questions load reliably; four + one challenge load reliably.

 Superscript and list‑answer parsing works for edge cases.

 Token logic, attempt counters, and grade‑level adjustments persist correctly.

 Unit tests (or React Testing Library tests) cover parsing helpers and state transitions.

 Lint & prettier pass; CI green.

Your Next Step
Do not start coding yet.
Please ask me any clarifying questions you have about:

Database schema details (e.g., full column list in questions_algebra).

Expected component props/API shapes.

Styling or UI/UX constraints.

Edge cases for parsing questions/answers.

Anything else you need before implementation.

Once I answer, proceed with the implementation plan.






